# UPS Power Management Server (Docker Edition)

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

A complete, containerized solution for managing graceful shutdowns for UPS-protected servers that lack a direct data monitoring port. It combines a virtual NUT (Network UPS Tools) server, a power monitoring script, and a central API hub for client configuration.

## About This Project

Many powerful, cost-effective UPS systems (like sine wave inverters with large external batteries) can power a server rack for hours but offer no way to signal a power failure to the connected devices. This project solves that problem by using a "canary in a coal mine" approach: it monitors several always-on devices (**sentinel hosts**) that are connected to standard, non-UPS grid power. If all of them go offline simultaneously, the application declares a power failure.

This container acts as the "brain" for a virtual NUT server, allowing standard NUT clients to perform a graceful shutdown. It also provides a central API to manage shutdown configurations for all clients.

This project is the perfect companion to the **[UPS\_monitor](https://github.com/MarekWo/UPS_monitor)** client script, which is a lightweight client designed to react to the status changes generated by this Power Manager.

-----

### How It Works

The logic is simple but effective:

1.  **Monitor:** A cron job inside the container runs a script (`power_manager.sh`) every minute to ping a list of user-defined sentinel hosts.
2.  **Decide:**
      * If **at least one** sentinel host is online, the script assumes grid power is OK and sets the virtual NUT server's status to `OL` (Online).
      * If **all** sentinel hosts are offline, the script assumes a power failure and sets the status to `OB LB` (On Battery, Low Battery).
3.  **Act:**
      * When NUT clients see the `OB LB` status, they fetch their specific shutdown delay from the built-in API and initiate a graceful shutdown.
      * When power is restored, the script sets the status back to `OL` and, after a configurable delay, sends Wake-on-LAN (WoL) packets to wake the servers that were shut down.

-----

### Features

  * **Hardware-Independent:** Works with any UPS, as it doesn't connect to it.
  * **Easy Deployment:** The entire multi-service application is containerized and managed with a single `docker-compose.yml` file.
  * **Centralized Configuration:** All client shutdown parameters are managed from a single `upshub.conf` file, served via a lightweight REST API.
  * **Standard-Compliant:** Controls a standard NUT server, making it compatible with any NUT client (Linux, Windows, Synology DSM, etc.).
  * **Automated Recovery:** Includes a delayed Wake-on-LAN function to automatically restart servers after stable power has returned.
  * **Robust Logging:** Includes built-in log rotation and optional, configurable forwarding to a central syslog server like Graylog.

-----

### Project Structure

```
.
‚îú‚îÄ‚îÄ app/                  # Main application scripts (power_manager.sh, api.py)
‚îú‚îÄ‚îÄ config/               # All user-editable configuration files
‚îú‚îÄ‚îÄ cron/                 # Cron job definition
‚îú‚îÄ‚îÄ logrotate/            # Log rotation configuration
‚îú‚îÄ‚îÄ rsyslog/              # (Optional) Syslog forwarding configuration
‚îú‚îÄ‚îÄ .gitignore            # Prevents local configs from being committed
‚îú‚îÄ‚îÄ Dockerfile            # The blueprint for the container image
‚îú‚îÄ‚îÄ docker-compose.yml    # The easy-run file for Docker Compose
‚îî‚îÄ‚îÄ entrypoint.sh         # The container's startup script
```

-----

### Prerequisites

  * A host machine that is **connected to the UPS** to run the container.
  * [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on the host machine.
  * A few reliable, always-on devices with static IPs on your network that are **NOT** connected to the UPS to act as sentinels.

-----

### Installation and Configuration

1.  **Clone the Repository:**

    ```bash
    git clone https://github.com/MarekWo/UPS_Server_Docker.git /opt/ups-server-docker
    cd /opt/ups-server-docker
    ```

2.  **Configure the Server:**
    All configuration is done by editing the files in the `./config/nut/` directory.

      * **`power_manager.conf`**:
          * `SENTINEL_HOSTS`: A space-separated list of IPs for your sentinel devices.
          * `WAKE_HOSTS`: A space-separated list of servers to wake up, in `IP;MAC` format.
          * `WOL_DELAY_MINUTES`: Recommended to be 5-10 minutes.
          * `BROADCAST_IP`: The broadcast address for your server subnet.
      * **`upshub.conf`**:
          * Define each client by its IP address in a section header (e.g., `[192.168.1.100]`).
          * Set `UPS_NAME` to point to the IP of your Docker host.
          * Set `SHUTDOWN_DELAY_MINUTES` for each client.
      * **`upsd.users`**:
          * (optional) Set a secure password for the `monuser`. This is what your UPS clients will use to connect.

      * First, copy the example configuration files:
        ```bash
        cp config/power_manager.conf.example config/power_manager.conf
        cp config/upshub.conf.example config/upshub.conf
        ```
      * Then, edit `config/power_manager.conf` and `config/upshub.conf` and replace the variables described above with your values. 

3.  **Time zone configuration:**   
    This allows you to setup your local timezone in your Docker container

      * First, copy the example environment file:
        ```bash
        cp .env.example .env
        ```
      * Then, edit `.env` and replace the TZ variable your your local timezone name.

4.  **(Optional) Configure Syslog Forwarding:**
    This allows you to send all internal logs to a central server like Graylog.

      * First, copy the example configuration file:
        ```bash
        cp rsyslog/custom.conf.example rsyslog/custom.conf
        ```
      * Then, edit `rsyslog/custom.conf` and replace the placeholder IP address and port with your syslog server details. 

## üîå Network Configuration for Wake-on-LAN (WoL)

The Wake-on-LAN (WoL) feature requires the container to send special "magic packets" to your network's **broadcast address**. Docker's default, sandboxed network mode prevents containers from sending broadcast packets to the physical LAN, which means the WoL feature will not work out of the box.

To enable WoL, you must allow the container to share the host's network stack.

#### Option 1: Full Functionality with `host` Network Mode (Recommended for WoL)

The simplest way to enable WoL is to add the `network_mode: host` directive to your `docker-compose.yml` file. This gives the container direct access to the host's network interfaces.

Your `docker-compose.yml` should be modified to include this line:

```yaml
version: '3.8'

services:
  ups-server:
    build: .
    container_name: ups-server
    restart: unless-stopped
    network_mode: host  # This line enables WoL functionality

    # NOTE: The 'ports' section is ignored in host mode and can be removed.
    # ports:
    #   - "3493:3493"
    #   - "5000:5000"
    
    # ... rest of your configuration
```

‚ö†Ô∏è **Security Note:** Using `network_mode: host` removes network isolation between the container and the host. The container gains access to all of the host's network interfaces and can bind to any port. While this application is built to be trustworthy, you should always be aware of the security implications of this setting. For more details, please see the [official Docker documentation on host networking](https://docs.docker.com/network/host/).

#### Option 2: Standard Network Isolation (WoL Disabled)

If you do not need the Wake-on-LAN feature or are not comfortable with using host network mode, simply **do not add** the `network_mode: host` line.

In this case, the NUT server and API will function correctly for monitoring and shutting down clients, but the ability to automatically wake them up will be disabled.

-----

### Usage

Once configured, starting the server is a single command from the project's root directory:

```bash
docker compose up --build -d
```

  * `--build`: Only needed the first time or after changing the `Dockerfile` or application scripts.
  * `-d`: Runs the container in the background (detached mode).

**Managing the Container:**

  * **View Logs:**
    ```bash
    docker compose logs -f
    ```
  * **Stop the Container:**
    ```bash
    docker compose down
    ```
  * **Restart the Container:**
    ```bash
    docker compose restart
    ```

You can also monitor the `power_manager.log` file in the `./logs` directory, which is created automatically on your host.

-----

### Updating

To update the application to the latest version from GitHub:

1.  **Pull the latest changes:**
    ```bash
    git pull
    ```
2.  **Rebuild the image and restart the container:**
    ```bash
    docker compose up --build -d
    ```
    Docker Compose will intelligently rebuild only what's necessary and restart the container with the latest updates. Your local configuration files will be preserved.

-----

### License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.