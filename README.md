# UPS Power Management Server (Docker Edition)

[](https://www.google.com/search?q=LICENSE)
[](https://www.docker.com/)

A complete, containerized solution for managing graceful shutdowns for UPS-protected servers that lack a direct data monitoring port. It combines a virtual NUT (Network UPS Tools) server, a power monitoring script, and a central API hub for client configuration.

## About This Project

Many powerful, cost-effective UPS systems (like sine wave inverters with large external batteries) can power a server rack for hours but offer no way to signal a power failure to the connected devices. This project solves that problem by using a "canary in a coal mine" approach: it monitors several always-on devices (**sentinel hosts**) that are connected to standard, non-UPS grid power. If all of them go offline simultaneously, the application declares a power failure.

This container acts as the "brain" for a virtual NUT server, allowing standard NUT clients to perform a graceful shutdown. It also provides a central API to manage shutdown configurations for all clients.

This project is the perfect companion to the **[UPS\_monitor](https://github.com/MarekWo/UPS_monitor)** client script, which is a lightweight client designed to react to the status changes generated by this Power Manager.

-----

### How It Works

The logic is simple but effective:

1.  **Monitor:** A cron job inside the container runs a script (`power_manager.sh`) every minute to ping a list of user-defined sentinel hosts.
2.  **Decide:**
      * If **at least one** sentinel host is online, the script assumes grid power is OK and sets the virtual NUT server's status to `OL` (Online).
      * If **all** sentinel hosts are offline, the script assumes a power failure and sets the status to `OB LB` (On Battery, Low Battery).
3.  **Act:**
      * When NUT clients see the `OB LB` status, they fetch their specific shutdown delay from the built-in API and initiate a graceful shutdown.
      * When power is restored, the script sets the status back to `OL` and, after a configurable delay, sends Wake-on-LAN (WoL) packets to wake the servers that were shut down.

-----

### Features

  * **Hardware-Independent:** Works with any UPS, as it doesn't connect to it.
  * **Easy Deployment:** The entire multi-service application is containerized and managed with a single `docker-compose.yml` file.
  * **Centralized Configuration:** All client shutdown parameters are managed from a single `upshub.conf` file, served via a lightweight REST API.
  * **Standard-Compliant:** Controls a standard NUT server, making it compatible with any NUT client (Linux, Windows, Synology DSM, etc.).
  * **Automated Recovery:** Includes a delayed Wake-on-LAN function to automatically restart servers after stable power has returned.
  * **Robust Logging:** Includes built-in log rotation and optional, configurable forwarding to a central syslog server like Graylog.

-----

### Project Structure

```
.
├── app/                  # Main application scripts (power_manager.sh, api.py)
├── config/               # All user-editable configuration files
├── cron/                 # Cron job definition
├── logrotate/            # Log rotation configuration
├── rsyslog/              # (Optional) Syslog forwarding configuration
├── .gitignore            # Prevents local configs from being committed
├── Dockerfile            # The blueprint for the container image
├── docker-compose.yml    # The easy-run file for Docker Compose
└── entrypoint.sh         # The container's startup script
```

-----

### Prerequisites

  * A host machine that is **connected to the UPS** to run the container.
  * [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on the host machine.
  * A few reliable, always-on devices with static IPs on your network that are **NOT** connected to the UPS to act as sentinels.

-----

### Installation and Configuration

1.  **Clone the Repository:**

    ```bash
    git clone https://github.com/MarekWo/UPS_Server_Docker.git /opt/ups-server-docker
    cd /opt/ups-server-docker
    ```

2.  **Configure the Server:**
    All configuration is done by editing the files in the `./config/nut/` directory.

      * **`power_manager.conf`**:
          * `SENTINEL_HOSTS`: A space-separated list of IPs for your sentinel devices.
          * `WAKE_HOSTS`: A space-separated list of servers to wake up, in `IP;MAC` format.
          * `WOL_DELAY_MINUTES`: Recommended to be 5-10 minutes.
          * `BROADCAST_IP`: The broadcast address for your server subnet.
      * **`upshub.conf`**:
          * Define each client by its IP address in a section header (e.g., `[192.168.1.100]`).
          * Set `UPS_NAME` to point to the IP of your Docker host.
          * Set `SHUTDOWN_DELAY_MINUTES` for each client.
      * **`upsd.users`**:
          * (optional) Set a secure password for the `monuser`. This is what your UPS clients will use to connect.

      * First, copy the example configuration files:
        ```bash
        cp config/power_manager.conf.example config/power_manager.conf
        cp config/upshub.conf.example config/upshub.conf
        ```
      * Then, edit `config/power_manager.conf` and `config/upshub.conf` and replace the variables described above with your values. 

3.  **(Optional) Configure Syslog Forwarding:**
    This allows you to send all internal logs to a central server like Graylog.

      * First, copy the example configuration file:
        ```bash
        cp rsyslog/custom.conf.example rsyslog/custom.conf
        ```
      * Then, edit `rsyslog/custom.conf` and replace the placeholder IP address and port with your syslog server details. 

-----

### Usage

Once configured, starting the server is a single command from the project's root directory:

```bash
docker compose up --build -d
```

  * `--build`: Only needed the first time or after changing the `Dockerfile` or application scripts.
  * `-d`: Runs the container in the background (detached mode).

**Managing the Container:**

  * **View Logs:**
    ```bash
    docker compose logs -f
    ```
  * **Stop the Container:**
    ```bash
    docker compose down
    ```
  * **Restart the Container:**
    ```bash
    docker compose restart
    ```

You can also monitor the `power_manager.log` file in the `./logs` directory, which is created automatically on your host.

-----

### Updating

To update the application to the latest version from GitHub:

1.  **Pull the latest changes:**
    ```bash
    git pull
    ```
2.  **Rebuild the image and restart the container:**
    ```bash
    docker compose up --build -d
    ```
    Docker Compose will intelligently rebuild only what's necessary and restart the container with the latest updates. Your local configuration files will be preserved.

-----

### License

This project is licensed under the MIT License - see the [LICENSE](https://www.google.com/search?q=LICENSE) file for details.