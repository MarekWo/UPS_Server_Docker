# UPS Power Management Server (Docker Edition)

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

A complete, containerized solution for managing graceful shutdowns for UPS-protected servers that lack a direct data monitoring port. It combines a virtual NUT (Network UPS Tools) server, a power monitoring script, a central API hub for client configuration, and a modern web interface for easy management.

## About This Project

Many powerful, cost-effective UPS systems (like sine wave inverters with large external batteries) can power a server rack for hours but offer no way to signal a power failure to the connected devices. This project solves that problem by using a "canary in a coal mine" approach: it monitors several always-on devices (**sentinel hosts**) that are connected to standard, non-UPS grid power. If all of them go offline simultaneously, the application declares a power failure.

This container acts as the "brain" for a virtual NUT server, allowing standard NUT clients to perform a graceful shutdown. It also provides a central API to manage shutdown configurations for all clients and a modern web interface for easy administration.

This project is the perfect companion to the **[UPS_monitor](https://github.com/MarekWo/UPS_monitor)** client script, which is a lightweight client designed to react to the status changes generated by this Power Manager.

-----

### How It Works

The logic is simple but effective:

1.  **Monitor:** A cron job inside the container runs a script (`power_manager.sh`) every minute to ping a list of user-defined sentinel hosts.
2.  **Decide:**
      * If **at least one** sentinel host is online, the script assumes grid power is OK and sets the virtual NUT server's status to `OL` (Online).
      * If **all** sentinel hosts are offline, the script assumes a power failure and sets the status to `OB LB` (On Battery, Low Battery).
3.  **Act:**
      * When NUT clients see the `OB LB` status, they fetch their specific shutdown delay from the built-in API and initiate a graceful shutdown.
      * When power is restored, the script sets the status back to `OL` and, after a configurable delay, sends Wake-on-LAN (WoL) packets to wake the servers that were shut down.

-----

### Features

  * **Hardware-Independent:** Works with any UPS because it doesn't require a direct data connection.
  * **Easy Deployment:** Fully containerized and managed with a single `docker-compose.yml` file.
  * **Modern Web GUI:** Intuitive web interface for configuration and monitoring, optimized for both desktop and mobile devices.
  * **Centralized Management API:** A lightweight REST API serves client configurations (`/config`) and live UPS status (`/upsc`), centralizing all client interactions.
  * **Live Status Monitoring:** Real-time status monitoring of all sentinel hosts and managed clients with automatic refresh.
  * **Standard-Compliant:** Controls a standard NUT server, making it compatible with any NUT client (Linux, Windows, Synology DSM, etc.).
  * **Automated Recovery:** Includes a delayed Wake-on-LAN function to automatically restart servers after stable power has returned.
  * **Unified Configuration:** Single configuration file (`power_manager.conf`) manages all aspects of the system.
  * **Robust Logging:** Includes built-in log rotation and optional, configurable forwarding to a central syslog server like Graylog.

-----

### Project Structure

```
.
â”œâ”€â”€ app/                  # Main application scripts
â”‚   â”œâ”€â”€ power_manager.sh  # Core monitoring script
â”‚   â”œâ”€â”€ api.py           # REST API server
â”‚   â”œâ”€â”€ web_gui.py       # Web interface application
â”‚   â””â”€â”€ templates/       # HTML templates for web GUI
â”œâ”€â”€ config/              # All user-editable configuration files
â”‚   â””â”€â”€ power_manager.conf # Main configuration file
â”œâ”€â”€ cron/                # Cron job definition
â”œâ”€â”€ logrotate/           # Log rotation configuration
â”œâ”€â”€ rsyslog/             # (Optional) Syslog forwarding configuration
â”œâ”€â”€ .gitignore           # Prevents local configs from being committed
â”œâ”€â”€ Dockerfile           # The blueprint for the container image
â”œâ”€â”€ docker-compose.yml   # The easy-run file for Docker Compose
â””â”€â”€ entrypoint.sh        # The container's startup script
```

-----

### Prerequisites

  * A host machine that is **connected to the UPS** to run the container.
  * [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on the host machine.
  * A few reliable, always-on devices with static IPs on your network that are **NOT** connected to the UPS to act as sentinels.

-----

### Installation and Configuration

1.  **Clone the Repository:**

    ```bash
    git clone https://github.com/MarekWo/UPS_Server_Docker.git /opt/ups-server-docker
    cd /opt/ups-server-docker
    ```

2.  **Prepare Docker Compose File:**
    Copy the example Docker Compose file. This ensures your customized file won't be overwritten by future `git pull` updates.
    ```bash
    cp docker-compose.yml.example docker-compose.yml
    ```
    You can now edit `docker-compose.yml` if you need to make advanced changes, but for most users, the default is fine.

3.  **Configure the Server:**
    All configuration is now managed through a single file: `./config/power_manager.conf`.

      * First, copy the example configuration file:
        ```bash
        cp config/power_manager.conf.example config/power_manager.conf
        ```
      * Then, edit `config/power_manager.conf` with your specific values:
          * `SENTINEL_HOSTS`: A space-separated list of IPs for your sentinel devices.
          * `WOL_DELAY_MINUTES`: The time in minutes to wait after power is restored before sending WoL packets.
          * `UPS_STATE_FILE`: The path to the state file used by the `dummy-ups` driver. **This must match the `port` setting in NUT configuration**.
          * `DEFAULT_BROADCAST_IP`: The default broadcast address for Wake-on-LAN packets.
          * `[WAKE_HOST_X]`: Sections defining each server to wake up. Each section requires:
            - `NAME`: Descriptive name for the host
            - `IP`: IP address of the host
            - `MAC`: MAC address for Wake-on-LAN
            - `BROADCAST_IP`: (optional) Specific broadcast IP for this host
            - `SHUTDOWN_DELAY_MINUTES`: (optional) Makes this host a UPS client with specified shutdown delay

4.  **Environment Configuration:**
    This file (`.env`) is used to pass crucial settings into the container, such as the host's IP address and your local timezone.

      * First, copy the example environment file if you haven't already:
        ```bash
        cp .env.example .env
        ```
      * Then, edit the `.env` file and set the following variables:
        * `TZ`: Your local timezone name (e.g., `Europe/Warsaw`).
        * `UPS_SERVER_HOST_IP`: **(Required)** The IP address of the Docker host machine. This is the IP that your NUT clients will use to connect to the server (e.g., `192.168.1.10`).

5.  **(Optional) Configure Syslog Forwarding:**
    This allows you to send all internal logs to a central server like Graylog.

      * First, copy the example configuration file:
        ```bash
        cp rsyslog/custom.conf.example rsyslog/custom.conf
        ```
      * Then, edit `rsyslog/custom.conf` and replace the placeholder IP address and port with your syslog server details.

### Example Configuration

Here's an example of the unified `power_manager.conf` file:

```bash
# === CONFIGURATION FILE FOR POWER_MANAGER.SH ===

# Sentinel hosts - devices on grid power (not UPS) for monitoring
SENTINEL_HOSTS=192.168.1.11 192.168.1.12 192.168.1.13 192.168.1.14

# Time to wait after power restoration before sending WoL packets
WOL_DELAY_MINUTES=5

# Path to the dummy-ups driver's state file
UPS_STATE_FILE=/var/run/nut/virtual.device

# Default broadcast address for WoL packets
DEFAULT_BROADCAST_IP=192.168.1.255

# === WAKE-ON-LAN HOST DEFINITIONS ===

# UPS Client with shutdown delay
[WAKE_HOST_1]
NAME=Synology NAS
IP=192.168.1.12
MAC=00:11:32:f8:af:9f
BROADCAST_IP=192.168.1.255
SHUTDOWN_DELAY_MINUTES=10

# Another UPS Client
[WAKE_HOST_2]
NAME=Proxmox Server
IP=192.168.1.13
MAC=00:11:32:2c:31:42
SHUTDOWN_DELAY_MINUTES=15

# WoL-only host (no UPS client functionality)
[WAKE_HOST_3]
NAME=File Server
IP=192.168.1.15
MAC=00:11:32:aa:bb:cc
```

## ðŸ”Œ Network Configuration for Wake-on-LAN (WoL)

The Wake-on-LAN (WoL) feature requires the container to send special "magic packets" to your network's **broadcast address**. Docker's default, sandboxed network mode prevents containers from sending broadcast packets to the physical LAN, which means the WoL feature will not work out of the box.

To enable WoL, you must allow the container to share the host's network stack.

#### Option 1: Full Functionality with `host` Network Mode (Recommended for WoL)

The simplest way to enable WoL is to add the `network_mode: host` directive to your `docker-compose.yml` file. This gives the container direct access to the host's network interfaces.

Your `docker-compose.yml` should be modified to include this line:

```yaml
version: '3.8'

services:
  ups-server:
    build: .
    container_name: ups-server
    restart: unless-stopped
    network_mode: host  # This line enables WoL functionality

    # NOTE: The 'ports' section is ignored in host mode and can be removed.
    # ports:
    #   - "3493:3493"
    #   - "5000:5000"
    #   - "80:80"
    
    # ... rest of your configuration
```

**Security Note:** Using `network_mode: host` removes network isolation between the container and the host. The container gains access to all of the host's network interfaces and can bind to any port. While this application is built to be trustworthy, you should always be aware of the security implications of this setting.

#### Option 2: Standard Network Isolation (WoL Disabled)

If you do not need the Wake-on-LAN feature or are not comfortable with using host network mode, simply **do not add** the `network_mode: host` line.

In this case, the NUT server and API will function correctly for monitoring and shutting down clients, but the ability to automatically wake them up will be disabled.

-----

## Web Interface

The UPS Server includes a modern, responsive web interface for easy configuration and monitoring.
![Dashboard](/images/web-ui-dashboard.png)

### Accessing the Web GUI

After starting the container, the web interface will be available at:

```
http://<UPS_SERVER_IP>
```

For example, if your UPS server host has IP `192.168.1.10`:
```
http://192.168.1.10
```

### Web GUI Features

* **Dashboard**: Real-time monitoring of system status, sentinel hosts, and UPS clients
* **Configuration Management**: Easy-to-use forms for managing all system settings
* **Live Status Updates**: Automatic refresh of host status every 30 seconds
* **Mobile Optimized**: Responsive design that works on all devices
* **One-Click Wake-on-LAN**: Send WoL packets directly from the interface

For detailed Web GUI documentation, see [WEB_GUI_README.md](WEB_GUI_README.md).

-----

### API Endpoints

The server provides a REST API for client configuration and status monitoring. All endpoints require an `Authorization` header with a bearer token. You must change the hardcoded token in `app/api.py` for a production environment.

**Example Request:**
```bash
curl -H "Authorization: Bearer <your_secret_token>" http://<server_ip>:5000/upsc
```

#### `GET /config`
This endpoint provides client-specific shutdown configuration. The client's IP address is used to look up its settings in the `WAKE_HOST_X` sections of `power_manager.conf`.

*   **Query Parameter:** `ip=<client_ip>` (optional, falls back to request source IP).
*   **Returns:** A JSON object with the client's configuration, including the dynamically generated `UPS_NAME` and `SHUTDOWN_DELAY_MINUTES`.

**Example Response (`/config?ip=192.168.1.12`):**
```json
{
  "SHUTDOWN_DELAY_MINUTES": "10",
  "UPS_NAME": "ups@192.168.1.10"
}
```

#### `GET /upsc`
This endpoint provides live status information from the NUT server, equivalent to running the `upsc` command locally, but with clean, nested JSON output.

*   **Returns:** A nested JSON object containing all available UPS variables. This is ideal for monitoring dashboards or advanced client-side logic.

**Example Response:**
```json
{
  "device": {
    "mfr": "Dummy Manufacturer",
    "model": "Dummy UPS",
    "type": "ups"
  },
  "driver": {
    "name": "dummy-ups",
    "parameter": {
      "mode": "dummy",
      "pollinterval": 2,
      "port": "/var/run/nut/virtual.device"
    },
    "version": "2.8.0",
    "version.internal": 0.15
  },
  "ups": {
    "mfr": "Dummy Manufacturer",
    "model": "Dummy UPS",
    "status": "OL"
  }
}
```

-----

### Services and Ports

The container provides the following services:

- **Port 80**: Web GUI interface
- **Port 5000**: REST API for client configuration
- **Port 3493**: NUT server for UPS clients

-----

### Usage

Once configured, starting the server is a single command from the project's root directory:

```bash
docker compose up --build -d
```

  * `--build`: Only needed the first time or after changing the `Dockerfile` or application scripts.
  * `-d`: Runs the container in the background (detached mode).

**Managing the Container:**

  * **View Logs:**
    ```bash
    docker compose logs -f
    ```
  * **Stop the Container:**
    ```bash
    docker compose down
    ```
  * **Restart the Container:**
    ```bash
    docker compose restart
    ```

You can also monitor the `power_manager.log` file in the `./logs` directory, which is created automatically on your host.

-----

### Updating

To update the application to the latest version from GitHub:

1.  **Pull the latest changes:**
    ```bash
    git pull
    ```
2.  **Rebuild the image and restart the container:**
    ```bash
    docker compose up --build -d
    ```
    Docker Compose will intelligently rebuild only what's necessary and restart the container with the latest updates. Your local configuration files will be preserved.

-----

### Migration from Previous Versions

If you're upgrading from a version that used separate `upshub.conf` configuration:

1. **Backup your current configuration:**
   ```bash
   cp config/power_manager.conf config/power_manager.conf.backup
   cp config/upshub.conf config/upshub.conf.backup
   ```

2. **Migrate UPS client settings:**
   Add `SHUTDOWN_DELAY_MINUTES` parameter to appropriate `[WAKE_HOST_X]` sections in `power_manager.conf` based on your old `upshub.conf` settings.

3. **Remove old configuration:**
   ```bash
   rm config/upshub.conf
   ```

4. **Update and restart:**
   ```bash
   docker compose up --build -d
   ```

-----

### License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.